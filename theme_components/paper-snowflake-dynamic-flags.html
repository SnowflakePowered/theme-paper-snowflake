<link rel="import" href="paper-snowflake-dynamic-flag">
<link rel="import" href="paper-snowflake-emulator-selector">
<polymer-element name="paper-snowflake-dynamic-flags" attributes="selectedGame">
  <template>
    <link rel="stylesheet" type="text/css" href="style/paper-snowflake-dynamic-flags.css"/>
    <div class="emulator-selector">
      <span>Emulator &mdash;</span><paper-snowflake-emulator-selector selectedGame="{{selectedGame}}" selectedEmulator="{{selectedEmulator}}" availableEmulators="{{availableEmulators}}"></paper-snowflake-emulator-selector>
    </div>

    <template repeat="{{flag in fkeys | getKeys}}">
    <paper-snowflake-dynamic-flag on-flag-refresh="{{flagRefresh}}" flag="{{fkeys[flag]}}" value="{{fvalues[flag]}}" gameId="{{selectedGame.UUID}}" emulatorName="{{selectedEmulator.name}}"></paper-snowflake-dynamic-flag>
    </template>
  </template>
  <script>
    Polymer('paper-snowflake-dynamic-flags', {
      publish: {
        fkeys : {},
        fvalues: {}
      },
      ready: function() {
        this.selected = 0;
        this.opened = false;
        window.d = this;
        this.valueSelected;
        this.defaultValues;

      },
      getKeys: function(o){
        return Object.keys(o);
      },
      flagUpdate: function(event){
        var name = this.selectedEmulator.name;
        snowflake.setFlagValue(this.selectedEmulator.name, this.selectedGame.UUID, event.detail.flag.Key, event.detail.value)
        .then((function(_this) {
          return function(data) {
            if (localStorage.getItem("custom_" + _this.selectedGame.UUID + ";" + _this.selectedEmulator.name + ";" + event.detail.flag.Key) === null && _this.fvalues[event.detail.flag.Key] !== _this.defaultValues[event.detail.flag.Key]) {
                localStorage.setItem("custom_" + _this.selectedGame.UUID + ";" + _this.selectedEmulator.name + ";" + event.detail.flag.Key, true);
                console.log(event.detail.flag.Key + " (" + event.detail.flag.Description + ") marked as customized for emulator " + name);
            }
            if (localStorage.getItem("custom_" + _this.selectedGame.UUID + ";" + _this.selectedEmulator.name + ";" + event.detail.flag.Key) ==! null) {
                console.log(event.detail.flag.Key + " (" + event.detail.flag.Description + ") already marked as customized for emulator " + name);
            }
            console.log(event.detail.flag.Key + " (" + event.detail.flag.Description + ") changed value to " + event.detail.value + " for emulator " + name);

          };
        })(this));
      },
      flagRefresh: function(){
        if(this.selectedGame !== undefined && this.selectedGame !== null){
          var hasProp = {}.hasOwnProperty;
          this.removeEventListener('flag-update', this.flagUpdate);
          snowflake.getEmulatorFlags(this.selectedEmulator.name).then((function(_this) {
            return function(data) {
              _this.fkeys = data;
              return snowflake.getFlagDefaultValues(_this.selectedEmulator.name); //Get flag default values
            };
          })(this))
          .then((function(_this) {
            return function(data) {
              _this.defaultValues = data;
              var flag, flags, i, key, len, values;
              values = {};
              flags = (function() { //Get the flag values that are not marked as custom
                var ref, results;
                ref = this.fkeys;
                results = [];
                for (key in ref) {
                  if (!hasProp.call(ref, key)) continue;
                  flag = ref[key];
                  if (localStorage.getItem("custom_" + this.selectedGame.UUID + ";" + this.selectedEmulator.name + ";" + flag.Key) === null) {
                    console.log(flag.Key + " is not customized, resyncing");
                    results.push(flag);
                  }
                }
                return results;
              }).call(_this);
              for (i = 0, len = flags.length; i < len; i++) { //for each flag that is not marked as custom, reset them to default
                flag = flags[i];
                values[flag.Key] = data[flag.Key];
              }
              return snowflake.setFlagValues(_this.selectedEmulator.name, _this.selectedGame.UUID, values);
            };
          })(this))
          .then((function(_this) {
            return function() {
              return snowflake.getFlagValues(_this.selectedEmulator.name, _this.selectedGame.UUID); //Get the newly synced flags from core
            };
          })(this))
          .then((function(_this) {
            return function(data) {
              console.log("Finished refreshing");
              _this.fvalues = data; //set flags as data, and start listening for flag updates
              _this.addEventListener('flag-update', _this.flagUpdate);
            };
          })(this));
        }
      },
      selectedEmulatorChanged: function(){
        this.async(function() {
          this.flagRefresh();
        }, null, 100);
      },
      selectedGameChanged: function(){
        console.log("game chaged");
        this.async(function() {
          this.flagRefresh();
        }, null, 100);
      }
    });
  </script>
</polymer-element>
<paper-snowflake-dynamic-flags></paper-snowflake-dynamic-flags>
